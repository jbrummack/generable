use std::{f64, fmt::Debug};

use crate::dynamic::schema::DynamicSchema;
pub mod description;
//pub mod gemini;
pub mod node;
pub mod schema;

pub trait DynamicGenerable {
    const REQUIRED: bool = true;
    fn dynamic_schema() -> DynamicSchema<&'static str>;
}
impl<T: DynamicGenerable> DynamicGenerable for Vec<T> {
    fn dynamic_schema() -> DynamicSchema<&'static str> {
        DynamicSchema::Array(Box::new(T::dynamic_schema()))
    }
}
impl<T: DynamicGenerable> DynamicGenerable for Option<T> {
    const REQUIRED: bool = false;
    fn dynamic_schema() -> DynamicSchema<&'static str> {
        DynamicSchema::Option(Box::new(T::dynamic_schema()))
    }
}
macro_rules! impl_dynamic_generable_for_ints {
    ($($t:ty),* $(,)?) => {
        $(
            impl DynamicGenerable for $t {
                fn dynamic_schema() -> DynamicSchema<&'static str> {
                    DynamicSchema::Integer {min: Self::MIN as i64, max: Self::MAX as u64}
                }
            }
        )*
    };
}
impl DynamicGenerable for serde_json::Number {
    fn dynamic_schema() -> DynamicSchema<&'static str> {
        DynamicSchema::Number {
            min: f64::MIN,
            max: f64::MAX,
        }
    }
}
impl_dynamic_generable_for_ints!(i8, i16, i32, i64, isize, u8, u16, u32, u64, usize,);
macro_rules! impl_dynamic_generable_for_floats {
    ($($t:ty),* $(,)?) => {
        $(
            impl DynamicGenerable for $t {
                fn dynamic_schema() -> DynamicSchema<&'static str> {
                    DynamicSchema::Number {min: Self::MIN as f64, max: Self::MAX as f64}
                }
            }
        )*
    };
}
impl_dynamic_generable_for_floats!(f64, f32);
macro_rules! impl_dynamic_generable_for_str {
    ($($t:ty),* $(,)?) => {
        $(
            impl DynamicGenerable for $t {
                fn dynamic_schema() -> DynamicSchema<&'static str> {
                    DynamicSchema::String
                }
            }
        )*
    };
}
impl_dynamic_generable_for_str!(
    std::string::String,
    &str,
    std::sync::Arc<str>,
    std::rc::Rc<str>,
);

macro_rules! static_value_type {
    ($name:ident, $value:expr) => {
        ///Autogenerated static serializable type string
        #[derive(Debug)]
        pub struct $name;
        impl serde::Serialize for $name {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_str($value)
            }
        }
    };
}
static_value_type!(Object, "object");
static_value_type!(String, "string");
static_value_type!(Array, "array");
static_value_type!(Boolean, "boolean");
static_value_type!(Number, "number");
static_value_type!(Integer, "integer");
#[derive(Debug)]
pub struct False;
impl serde::Serialize for False {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_bool(false)
    }
}
#[derive(Debug)]
pub struct True;
impl serde::Serialize for True {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_bool(true)
    }
}
