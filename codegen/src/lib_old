//mod primitives;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
mod compound;
use syn::{Data, DeriveInput, LitStr, parse_macro_input};
/*#[proc_macro_derive(GenerableDynamic, attributes(describtion))]
pub fn gen_fields2(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    impl_gen_fields2(&input).into()
}*/

#[proc_macro_derive(Generable, attributes(description))]
pub fn gen_fields(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    impl_gen_fields(&input).into()
}
fn impl_cache_generation(input: &DeriveInput) -> proc_macro2::TokenStream {
    let name = &input.ident;
    let cache_name = format!("UP_CACHED_{}", name.to_string().to_uppercase());
    let cache_error_msg = format!("Failed to preprocess {}", name.to_string());
    let parent_description = input
        .attrs
        .iter()
        .find(|a| a.path().is_ident("description"))
        .and_then(|attr| attr.parse_args::<syn::LitStr>().ok())
        .map(|lit| lit.value());
    let cache_error_msg_lit = LitStr::new(&cache_error_msg, Span::call_site());
    let cached_ident = syn::Ident::new(&cache_name, Span::call_site());
    let struct_data_descr = parent_description
        .map(|parent_description| {
            let descr_lit = LitStr::new(&parent_description, Span::call_site());
            quote! {
                #name::schema(Some(#descr_lit))
            }
        })
        .unwrap_or(quote! {#name::schema(None)});
    quote! {
        static #cached_ident: std::sync::LazyLock<Box<serde_json::value::RawValue>> = LazyLock::new(|| {
            let struct_data = #struct_data_descr;
            //struct_data.set_strict();
            let rv = RawValue::from_string(
                serde_json::to_string(&struct_data).expect(#cache_error_msg_lit),
            )
            .expect(#cache_error_msg_lit);
            rv
        });
        impl generable::CachedGenerable for #name {
            fn get_schema() -> Box<serde_json::value::RawValue> {
                #cached_ident.clone()
            }
        }
    }
}

fn impl_gen_fields(input: &DeriveInput) -> proc_macro2::TokenStream {
    let name = &input.ident;

    let fields = match &input.data {
        Data::Struct(data) => &data.fields,
        _ => panic!("Describe can only be derived for structs, enums"),
    };

    let property_field_handlers = fields.iter().map(|field| {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;

        let desc = field
            .attrs
            .iter()
            .find(|a| a.path().is_ident("description"))
            .and_then(|attr| attr.parse_args::<syn::LitStr>().ok())
            .map(|lit| lit.value());
        //.unwrap_or_else(|| field_name.to_string());
        let field_literal = LitStr::new(&field_name.to_string(), Span::call_site());
        if let Some(description) = desc {
            let description_literal = LitStr::new(&description, Span::call_site());
            quote! {
                let schema =  <#field_type>::schema(Some(#description_literal));
                let fname = #field_literal;
                output.insert(fname, schema);
            }
        } else {
            quote! {
                let schema =<#field_type>::schema(None);
                let fname = #field_literal;
                output.insert(fname, schema);
            }
        }
    });
    let required_field_handlers = fields.iter().map(|field| {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;
        let field_literal = LitStr::new(&field_name.to_string(), Span::call_site());
        quote! {
            if <#field_type>::REQUIRED {
                fields.push(#field_literal);
            }
        }
    });
    let cached_schema = impl_cache_generation(input);

    quote! {
        #cached_schema
        impl generable::Generable for #name {
            fn required_fields() -> Option<Vec<&'static str>> {
                let mut fields = Vec::new();
                #(#required_field_handlers)*
                Some(fields)
            }
            fn properties() -> Option<HashMap<&'static str, SchemaObject>> {
                let mut output = std::collections::HashMap::new();
                #(#property_field_handlers)*
                Some(output)
            }
        }
    }
}
